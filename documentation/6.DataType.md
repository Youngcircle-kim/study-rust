## Data type

RUST와 같이 정적 타입 언어들은 모든 값은 특정한 타입을 가진다.
이는 컴파일 시점에 타입이 반드시 정해져 있음을 시사한다.

RUST의 타입은 2가지로 나눌 수 잇다.

1. 스칼라 타입
2. 복합 타입

#### 스칼라 타입 (Scalar type)

스칼라 타입은 하나의 값을 표현한다.
RUST에서는 정수, 부동 소수점 숫자, 부울린, 문자 이렇게 4가지 스칼라 타입을 갖고 있다.

##### 정수형 (Integer type)

정수형 타입은 소수점이 없는 숫자.
정수형 타입은 일반적으로 부호 있음(signed)과 부호없음(unsigned)으로 나뉜다.

각 정수형의 사이즈는 8, 16, 32, 64, 128, arch로 나뉘어진다.

여기서 arch는 본인 컴퓨터 아키텍처에 따라 달라진다.

RUST에서는 자바와 같이 정수형 가운데 `_`삽입이 가능하다. 즉, `1_000`이 가능하다.

숫자 리터럴도 앞의 접두사를 붙여 사용할 수 있다. 리터럴의 종류는 다음과 같다.

1. Decimal ; 98_222
2. Hex ; 0xff
3. Binary ; 0b1111_0000
4. Byte(`u8` only) ; b'A'

##### 부동 소수점 타입 (Floating-point type)

Rust에서 `Floating-point`는 두가지로 분류된다.

1. `f32` : 1배 수 정밀도(Single precision, 단정밀도), 32bit
2. `f64` : 2배 수 정밀도(Double precision, 배정밀도), 64bit

##### 수치 연산

```rust
fn main() {
    // 덧셈
    let sum = 5 + 10;

    // 뺄셈
    let difference = 95.5 - 4.3;

    // 곱셈
    let product = 4 * 30;

    // 나눗셈
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 결괏값은 -1입니다

    // 나머지 연산
    let remainder = 43 % 5;
}
```

##### 부울린 타입 (Boolean type)

다른 언어와 `true`와 `false` 두 값을 가질 수 있다.
값은 1바이트다.

```rust
fn main() {
    let t = true;

    let f: bool = false; // 명시적인 타입 어노테이션
}
```

##### 문자 타입(Character type)

RUST의 `char`는 가장 기본적인 알파벳 타입이다.

```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // 명시적인 타입 어노테이션
    let heart_eyed_cat = '😻';
}
```

문자열 리터럴이 큰따옴표를 사용하는 대신, `char` 타입은 작은따옴표를 사용한다.
`char`는 4바이트 크기이며, 유니코드 스칼라 값을 표현하며, 이는 ASCII보다 훨씬 더 많은 값을 표현할 수 있다.

#### 복합 타입(Compound type)

복합 타입은 여러 값을 하나의 타입으로 묶을 수 잇다.
러스트에는 튜플(tuple), 배열(array) 두가지 기본 복합 타입이 있다.

##### 튜플 타입

다양한 타입의 여러 값을 묶어 하나의 복합 타입으로 만드는 일반적인 방법.
고정된 길이를 갖는다. 선언 이후에는 크기를 늘리거나 줄일 수 없다.

```rust
fn main() {
    // 괄호 안에 쉼표로 구분하여 값들의 목록을 작성
    let tup: (i32, f64, u8) = (500, 6.4, 1); // 명시적 타입 어노테이션
    // 각 위치가 독립적인 타입을 갖고, 서로 달라도 된다.
}
```

```rust
fn main() {
    let tup = (500, 6.4, 1);
    let (x,y,z) = tup; // tuple의 destructuring
    println!("The value of y is : {y}");
}
```

Destructuring을 할 때, tuple 안에 element 개수가 맞지 않으면, 에러가 발생한다.
접근은 `.`뒤에 인덱스를 넣어 접근이 가능하다.

##### 배열 타입

여러 값의 집합체를 만드는 다른 방법으로는 array가 있다.
튜플과 달리 모든 요소는 모두 같은 타입이여야 한다. 또한 크기 또한 고정이다.

```rust
fn main(){
    let a = [1,2,3,4,5];
}
```

선형 자료구조를 생각할 때, 힙보다는 스택에 데이터를 할당하고 싶을 때나, 
항상 고정된 개수의 요소로 이루어진 경우라면 배열이 유용하다.
하지만, 자료구조가 유연해야 한다면 벡터를 선택하자.</br>
요소의 개수가 바뀔 필요가 없다면 배열.</br> 잘 모르겠다면 벡터를 사용하자.

```rust
fn main(){
    let a: [i32; 5] = [1, 2, 3, 4, 5]; // 명시적 어노테이션
    let a = [3; 5]; // let a = [3, 3, 3, 3, 3];
    let first = a[0]; // 배열 index 접근
}

``을

러스트는 OutOfBounds 에러를 Panic을 발생시켜 즉시 종료.