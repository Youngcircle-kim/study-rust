## 변수

#### 가변성

이전에도 언급했듯이, RUST에서 변수는 기본적으로 `Imutable`이다. 이 말은 `Mutable` 변수를 생성하지 못한 다는 이야기는 아니다.

`imutable` 변수는 아래와 같이 `mut` 키워드 없이 생성되는 변수를 의미한다.

```rust
fn main(){
    let x: i32 = 5; // Imutable 변수
    println!("x = {x}");
    x = 6; // Compile Error
}
```

위 예제처럼 `Imutable` 변수에 값을 두번 할당하면, 컴파일 에러가 생긴다.
`Imutable` 변수는 나중에 값이 어떻게 바뀔지를 추적하지 않아도 되기 때문에, 코드의 흐름을 찾기 쉬워진다.

#### 상수

상수(Constant)는 불변 변수와 비슷한데, 어떤 이름에 묶여 있는 값이고 값을 바꾸는 것이 허용되지 않지만, 변수와는 약간 다른 점들이 있다.

상수의 특징은 다음과 같다.

1. 상수는 기본적으로 `const` 키워드를 통해 변수를 생성한다.
2. 데이터 타입이 무조건 명시되어야 한다.
3. 마지막으로 런타임에서 계산될 수 있는 결괏값으로는 안된다.

```rust
const DAY_IN_SECONDS: u32 = 60 * 60 * 24;
```

#### 섀도잉

새 변수를 이전 변수명과 같은 이름으로 선언할 수 있다.
RUST 유저들은 첫 번째 변수가 두 번째 변수에 의해 가려졌다.(Shadowed) 라고 표현하며, 이는 해당 변수의 이름을 사용할 때 컴파일러가 두 번째 변수를 보게 될 것이라는 의미이다.
실제로 두번째 변수는 첫 번째 것을 가려서, 스스로를 다시 가리거나 스코프가 끝날 때까지 변수명의 사용을 가져간다.

```rust
fn main(){
    let x = 5;
    let x = x + 1;

    // 하위 스코프 생성
    {
        let x = x *2 ;
        println!("x = {x}"); // print : x = 12
    }
    // 하위 스코프 내용 버림

    println!("x = {x}"); // print : x = 6
}
```

여기까지 읽는다면, `mut`과 `shadowing`의 차이가 궁금할 것이다.
이 둘의 차이는 `shadowing`은 `let`을 무조건으로 적용을 해줘야 한다.
이에 반해 `mut`은 `let` 키워드 없이 재할당 할 수 있다.
또한 `mut`을 사용할 때 데이터 타입에 유의하자.
